\documentclass{beamer}
\usetheme[compress]{Singapore}
\useoutertheme{miniframes}

% \documentclass{beamer}
%\usetheme{Warsaw}

% Pour les documents en francais...
	\usepackage[latin1]{inputenc}
	\usepackage[french]{babel}
	\usepackage[french]{varioref}

% Mathématiques
	\usepackage{amsmath}

% Caracteres speciaux supplémentaires
	\usepackage{latexsym,amsfonts}

% A documenter
	\usepackage{moreverb}

% Macros pour les paquets
	\usepackage{array}  			% Nécessaires pour les tableaux de la macro Excel.

% Outil supplémentaire pour les tableaux
	\usepackage{multirow}
	\usepackage{booktabs}
	\usepackage{xcolor} % alternating row colors in table, incompatible avec certains modules
	\usepackage{longtable}
	\usepackage{colortbl}

% Pour insérer des graphiques
	\usepackage{graphicx} 			% Graphique simples
	\usepackage{subfigure}			% Graphiques multiples

% Pour insérer des couleurs
	\usepackage{color}

% Rotation des objets et des pages
%	\usepackage{rotating}
%	\usepackage{lscape}

% Pour insrer du code source, LaTeX ou SAS par exemple.
	\usepackage{verbatim}
        \usepackage{moreverb}
	\usepackage{listings}
	\usepackage{fancyvrb}

%	\lstset{language=SAS,numbers=left}		% Par dfaut le listing est en SAS

% Pour insérer des hyperliens
  \usepackage{hyperref}

% American Psychological Association (for bibliographic references).
	\usepackage{apacite}

% Pour l'utilisation des macros
	\usepackage{xspace}

% Pour l'utilisation de notes en fin de document.
%	\usepackage{endnotes}

% Array
%	\usepackage{multirow}
%	\usepackage{booktabs}

% Rotation
%	\usepackage{rotating}

% En têtes et pieds de pages
%	\usepackage{fancyhdr}
%	\usepackage{lastpage}


% Page layout

% By LaTeX commands
%\setlength{\oddsidemargin}{0cm}
%\setlength{\textwidth}{16cm}
%\setlength{\textheight}{24cm}
%\setlength{\topmargin}{-1cm}
%\setlength{\marginparsep}{0.2cm}

% fancyheader parameters
%\pagestyle{fancy}

%\fancyfoot[L]{{\small Formation \LaTeX, DEPP}}
%\fancyfoot[c]{}
%\fancyfoot[R]{{\small \thepage/\pageref{LastPage}}}

%\fancyhead[L]{}
%\fancyhead[c]{}
%\fancyhead[R]{}

% Pour insérer des dessins de Linux
\newcommand{\LinuxA}{\includegraphics[height=0.5cm]{Graphiques/linux.png}}
\newcommand{\LinuxB}{\includegraphics[height=0.5cm]{Graphiques/linux.png}\xspace}

% Macro pour les petits dessins pour les différents OS.
\newcommand{\Windows}{\emph{Windows}\xspace}
\newcommand{\Mac}{\emph{Mac OS X}\xspace}
\newcommand{\Linux}{\emph{Linux}\xspace}
\newcommand{\MikTeX}{MiK\tex\xspace}
\newcommand{\latex}{\LaTeX\xspace}


\newcommand{\df}{\emph{data.frame}\xspace}
\newcommand{\dfs}{\emph{data.frames}\xspace}
\newcommand{\liste}{\emph{list}\xspace}
\newcommand{\cad}{c'est-à-dire\xspace}

% Titre
\title{Introduction à R}
\author{Pascal Bessonneau}
%\institute{DEPP}
\date{06/2015}
\subtitle{Les types d'objets}


\newcommand{\hreff}[2]{\underline{\href{#1}{#2}\xspace}}

<<defaults,results='hide',echo=FALSE>>=
require(MASS,quietly=T,warn.conflicts=FALSE)
require(xtable,quietly=T,warn.conflicts=FALSE)
require(stringr,quietly=T,warn.conflicts=FALSE)
require(RSQLite,quietly=T,warn.conflicts=FALSE)
require(foreign,quietly=T,warn.conflicts=FALSE)
suppressPackageStartupMessages(require(XLConnect,quietly=T,warn.conflicts=FALSE))

opts_chunk$set(fig.path='graphiques/beamer-',fig.align='center',fig.show='hold',size='footnotesize',
               fig.height=7,fig.width=7,out.width="\\textwidth",resize.height="0.8\\textheight",
               tidy=FALSE,prompt=TRUE
               )

options(width=45)

@

\begin{document}

\begin{frame}
	\maketitle
\end{frame}

\begin{frame}
	\tableofcontents
\end{frame}

% Begin document %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{les objets de base}

\begin{frame}[containsverbatim]
  \frametitle{Vecteurs}

  L'objet le plus courant est de loin le vecteur. il s'agit d'un tableau à 1 
  dimension stockant un seul et unique type de données.
  
  La création d'un vecteur est soit implicite soit explicite.
  
  Implicite avec l'opérateur \emph{c}~:
  
<<>>=
c(2,3,4,6,7)
@

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{Vecteurs}

  Soit explicite en appelant un créateur qui porte le nom du type que l'on 
  souhaite stocké et sa longueur~:
  
<<>>=
numeric(4)
logical(4)
@

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{Les fonctions associées aux types}
  
  Il existe deux familles de fonctions associées aux types~:
  \begin{description}
    \item[is.] les fonctions \emph{is.} renvoie un booléen indiquant si la valeur
    appartient à un type donné
    \item[as.] ces fonctions permettent de changer le type d'une valeur vers une
    autre (cast)
  \end{description}
  
  
<<>>=
is.integer(2L)
is.character(2.3)
as.character(2)
@

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{Matrices}

  Ensuite viennent les matrices qui sont des tableaux à deux dimensions~:
  
<<>>=
matrix( 0, ncol = 2, nrow = 2)
@

  Les matrices sont créés avec un premier argument qui contient les données et 
  une (ou deux tailles, largeur et/ou longueur).

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{Matrices}

  
<<>>=
matrix( 0, ncol = 2, nrow = 2)
@

  Les matrices sont créés avec un premier argument qui contient les données et 
  une (ou deux tailles, largeur et/ou longueur).

  Le type de données, \emph{unique}, stocké pour les matrices est le type de 
  données par le premier argument.

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les \emph{data.frame}}

  Les \dfs sont des tableaux comme les matrices mais qui permettent de stocker
  des types de données différentes dans chaque colonne.

<<>>=
head(data.frame(lettre=LETTERS,numero=1:26))
@

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les \emph{data.frame}}

  Les \dfs sont de loin la structure la plus utilisée en faisant de la 
  manipulation de données. 
  
  Mais ce type dérive en fait d'un autre type de base moins manipulable par les
  débutants~: les listes.

  
\end{frame}

\section{les objets moins courants}

\begin{frame}[containsverbatim]
  \frametitle{les \emph{list}}

  Les \emph{list} sont la structure la plus pratique. Ce sont des vecteurs où
  chaque élement du vecteur peut être un objet R quelconque y compris une liste.

<<>>=
a=list(1, LETTERS, matrix(0,2,2))
str(a)
@

\end{frame}


\begin{frame}[containsverbatim]
  \frametitle{les \emph{list}}

  Les \dfs sont en fait une liste avec comme condition que chaque élement soit
  un vecteur de même longueur (pour obtenir un tableau).
  
  Ainsi les listes et les \dfs partagent beaucoup d'opérateurs en communs.

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les \emph{array}}

  les \emph{array} sont des objets qui étendent les matrices à des tableaux
  à \emph{k}-dimsions. 
  
<<>>=
array(1:4,c(2,2,2))
@

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les \emph{list}}

  Les \dfs sont en fait une liste avec comme condition que chaque élement soit
  un vecteur de même longueur (pour obtenir un tableau).
  
  Ainsi les listes et les \dfs partagent beaucoup d'opérateurs en communs.

  Dans la programmation avancée, les \dfs sont souvent utilisées comme des 
  listes.

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les séries temporelles}

  Les séries temporelles sont des des élements pouvant stocker et avec des 
  propriétés particulières des séries de date.
  
  C'est le type utilisé pour tous les analyses en séries temporelles.
  
<<>>=
ts(date())
@
  
\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{Les fonctions de transformation}
  
  Il existe deux familles de fonctions associées aux types~:
  \begin{description}
    \item[is.] les fonctions \emph{is.} renvoie un booléen indiquant si la valeur
    appartient à un objet donné
    \item[as.] ces fonctions permettent de changer un objet dans un autre type
  \end{description}

<<>>=
str(as.list(iris))
str(as.matrix(iris[,1:4]))
@

\end{frame}

\section{Nommage des élements d'un objet}

% à remplir


\section{Les trois aspects de l'indexation}

\begin{frame}[containsverbatim]
  \frametitle{Dans cette partie\dots}
  
  \dots sont décrites les principales règles qui permettent de sélectionner une
  partie des objets les plus courants (le langage objet S4 est exclus).
  
\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{Pour un vecteur}

    Pour un vecteur, l'opérateur d'extraction de valeurs sont des crochets.
    simples.
    
    Comme on peut le voir sur les deux dernières lignes leur précédence n'est pas
    très forte mais plus grande que les opérateurs de calcul.
    
<<>>=
LETTERS[1:10]    
c(1,2,3,4)[1:2]
c(1,2,3,4)[-4]
c(1,2,3,4)[-4] * 2
@

\end{frame}


\begin{frame}[containsverbatim]
  \frametitle{Les trois aspects de l'indexation}

    L'indexation sauf certaine exception peut se faire avec trois types de 
    données sous R.
    \begin{description}
      \item[entiers] avec les entiers, les chiffres positifs indiquent les
      positions des vecteurs qui seront extraits. Les chiffres négatifs indiquent
      les positions à exclure. Attention on ne peux pas mélanger chiffre
      positif et chiffres négatifs
    \end{description}
    
\end{frame}
    
\begin{frame}[containsverbatim]
  \frametitle{les entiers}

  Avec les entiers, les chiffres positifs indiquent les positions des vecteurs 
  qui seront extraits. Les chiffres négatifs indiquent les positions à exclure. 
  
  La longueur est quelconque (mais supérieur ou égal à 1). La longueur 
  corresponds au nombre de d'éléments à extraire (ou à ne pas extraire).
  
  Attention on ne peux pas mélanger chiffres positifs et chiffres négatifs
  
  Attention Attention, amoureux du C et du perl, le zéro n'est jamais un indice 
  valide en R.
  
\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les entiers}
  
  
  La longueur du vecteur retourné est la longueur du vecteur de sélection pour
  les nombres d'entiers. 
  
  Pour les nombres négatifs, la longueur retournée est le total d'elements uniques
  du vecteurs moins la longueur du vecteur de sélection.
  
\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les entiers}
  
<<>>=
LETTERS[c(1,2,3,4)]
LETTERS[c(2,4)]
LETTERS[c(2,4,2)]
@

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les entiers}
  
<<>>=
LETTERS[-c(1,2,3,4)]
LETTERS[-c(2,4)]
LETTERS[-c(2,4,2)]
@
  
\end{frame}


\begin{frame}[containsverbatim]
  \frametitle{le vecteur logique}
  
  La grande différence avec les indices numériques est la longueur du vecteur.
  
  Pour chaque position, si la valeur est \emph{TRUE}, la valeur est retournée.
  Si c'est \emph{FALSE}, la valeur n'est pas retourné.
  
  Par conséquent la longueur du vecteur de sélection est la longueur du vecteur
  à séléctionner. Quant à la la longueur du vecteur de retour, c'est le nombre
  de \emph{TRUE} (ie. la somme du vecteur logique).
  
  Attention au recyclage ! Si le recyclage n'est pas possible R génère une erreur
  si la longueur des deux vecteurs ne coïncide pas.
  
\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{le vecteur logique}

<<>>=
L <- LETTERS[1:6]
L
L[c(T,F,T,F,T,T)]
L[c(T,F)] # recyclage
@

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les noms}

  Les noms ont été évoqués brièvement\dots à peu près tout sous R peut porter un
  noms. 
  
  On peut donc utiliser un vecteur \emph{character} avec le noms des élements
  pour les récupérer.

  Les noms peuvent être utilisés en lieu et place des numéros. La longueur du
  vecteur de retour est alors le nombre de noms mis en arguments.
  
\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{les noms}

<<>>=
(a <- 1:4)
(names(a) <- LETTERS[1:4])
a[c("A","D","A","C")]
@

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{Généralisation du système d'indexation}
  
  Une fois compris ce système d'indexation, le plus dur est   fait car c'est sur
  ce système que se base pratiquement tout l'indexation des lignes et des
  colonnes d'une matrice, des élements d'une liste, \dots
  
  Quand l'objet est composé de lignes et de colonnes il suffit d'indexer et 
  d'ajouter une "," pour indiquer à R sur quel dimensions on travaille.
  
\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{\dfs et matrices}
  
<<>>=
str(iris[c(1,3,4),]) # à gauche -> lignes
str(iris[,c(2,4,5)]) # à doirte -> colonnes
str(iris[c(2,4,5),c(2,4,5)]) # les deux
@

\end{frame}


\begin{frame}[containsverbatim]
  \frametitle{Listes}
  
  Les listes sont proches des vecteurs. Les mêmes règles peuvent être appliquées.
  
  Il y a toutefois une subtilité. Entre crochets simples, les listes renvoie
  une liste. Mais entre crochets doubles, un seul élement peut être renvoyé mais
  l'élement n'est pas de type liste mais du type contenu dans la liste à cette 
  position.
  
  C'est logique puisque vu l'hétérogénéité des élements pouvant être stockés
  dans une liste, R ne peut déterminer la meilleure stratégie pour rendre une
  série d'objets hétérogène.
  
  Par contre quand un seul objet est renvoyé ce problème ne se pose pas.
  
\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{Listes}

<<>>=
a <- list(1, LETTERS, matrix(0,2,2))
a[c(T,F,T)]
a[[1]]
@

\end{frame}

\begin{frame}[containsverbatim]
  \frametitle{Listes}

  Pour les \emph{data.frame} et pour les \emph{list}s, il existe un opérateur
  supplémentaire qui permet de sélectionner un élement par son nom,

<<>>=
a <- list(z=1, R=LETTERS, matrix(0,2,2))
a$R
@


\end{frame}


\begin{frame}[containsverbatim]
  \frametitle{Listes}

  Cette syntaxe est particulièrement utile sur les \emph{data.frame} où on 
  sélectionne ainsi les variables~:
<<>>=
head(iris$Species)
@

\end{frame}


\end{document}
